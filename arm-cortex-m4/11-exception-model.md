# Exception Model

## What is exception?

Anything which distrubs the normal flow of the program is called exception. It can be a hardware interrupt or software interrupt.

Two types of exceptions:
* System exception: Generated by the processor when it detects an error condition.
* Interrupt: Generated by the peripherals or external devices.

Whenever an exception occurs, the processor will stop the current execution and change the mode to handler mode.

There are 15 system exceptions in ARM Cortex M4 processor and 240 interrupts.

## Different System Exceptions

1. There is room for 15 system exceptions in ARM Cortex M4 processor.

1. **Reset**: This is the first exception that occurs when the processor is reset. It is a system exception.

1. Only 9 system exceptions are defined in the ARM Cortex M4 processor. The rest of the 6 exceptions are reserved.

1. Exception number 16 to 31 are reserved for the interrupts. 16 is Interrupt 1 (IRQ 0)

Refer to the ARM Cortex M4 technical reference manual for more details about each definittion of the system exception.

## System Exception Vector Table

The vector table contains the reset value of the stack pointer, and the start addresses, also called exception vectors, for all exception handlers.

Refer to ARM Cortex M4 technical reference manual for the vector table.

## System Exception Control Registers

* PPB region contains register for processor specific peripheral.

### System Control Block (SCB)

* The system control block provides system implementation and system control. This includes configuration, control, and reporting of system exceptions.

Explore the generic user guide for more details about SCB.

* System Handler Priority Register (SHPR) is used to set the priority of the system exceptions handler.

* There are also registers for fault status, fault address, and fault control.

*System Handler Control and State Register (SHCSR) is used to enable or disable the system exceptions.

By using SCB:
* You can enable or disable the system exceptions.
* Get pending status of the system exceptions.
* Trap processor for divide by zero or unaligned access.
* Control sleep and sleep wake up settings
* Configure the priority of the system exceptions.
* Systick timer control and status.

Oly some system exceptions are enabled by default. You can enable or disable the system exceptions by using the SCB registers.

## NVIC

* Nested Vectored Interrupt Controller (NVIC) is one of the peripheral of ARM cortext Mx used to control the interrupts.

* It is used to configure 240 interrupts.

* Using NVIC registers you can enable/disable/pend various interrupts and read the status of the active and pending interrupts.

* You can configure the priority and priority grouping of various interrupts.

* It is called as nested because, it supports pre-empting a lower priority interrupt handler when higher priority interrupt arrives.

### Enable/Disable/Pending various interrupts

1. Cortext M4 supports 240 interrupts.
1. These interrupts are managed and configured using NVIC
1. What are the 240 interrupts? => find it in MCU reference manual.
    * SPI, GPIO, CAN, Timers, DMAS, etc

1. Each MCU Vendor can connect different peripherals to the NVIC. IRQ numbers is belong to the processor core. 

    * I2c in MCU ==> NVIC pin 4 ==> IRQ4 is connected to I2C peripheral.

### NVIC Registers

#### Interrup Set Enable Register (ISER) 

ISER0-7 registers are used to enable the interrupts. Each bit in the register corresponds to an interrupt.

ISER0 can be used to enable interrupts from 0 to 31.

#### Interrupt Clear Enable Register (ICER)

If you set to 1, it will disable the interrupt.

#### Interrupt Set Pending Register (ISPR)

Force the interrupt into pending state. When it is pended, processor will check the priority and execute the interrupt handler based on the priority.


#### Interrupt Clear Pending Register (ICPR)

Remove the interrupt from the pending state. When you read the register, it will shows which interrupt is pending.

#### Interrupt Active Bit Register (IABR)

It shows which interrupt is active. This indicate which interrupt is currently being executed by the processor.

### Peripher Interrupt Exercise

Exercise is to enable and pending the interrupt of USART3.

#### Steps to program an MCU peripheral interrupt

1. Idenfity the IRQ number of the peripheral by referring to the MCU reference manual. IRQ number is vendor specific.
1. Program the processor register to enable that IRQ (only when you enable the IRQ, the processor will accept the interrupt over that line). 
1. Set the priority of the interrupt (optional).
1. Configure the peripheral (USART3) using its peripheral configuratio register. In the case of USART3, whatever a packet is received, it will automatically issue an interrupt on the IRQ line 84 in Cortext M7.
1. When the interrupt is issued on the IRQ line, it will first get pended in the pending register of the processor.
1. NVIC will allow the IRQ handler associated with the IRQ number to run only if the priority of the new interrupts higher than the currently executing interrupt handler. Othwrwise newly arrived interrupt will stay in pending state.
1. Please note that if peripheral issues an interrupt when the IRQ number is disavled (not activated from the processor side), then still interrupt will get pended in the pending reigster of the NVIC. As soon as IRQ enabled, it will trigger the execution of the ISR if the priority is higher than the currently executing ISR.

#### How USART can issue an interrupt?

1. Data packet arrives at the USART RX peripheral buffer.
1. When the buffer is full, the USART peripheral will issue an interrupt on the IRQ line 84.
1. When interrupt is issued, it will get pended in the NVIC pending register.
1. If the IRQ is enabled, the processor will execute the ISR associated with the IRQ number 84. 
    * CPU fetch the ISR address from the vector table and start executing the ISR.
    * PC jumps to the ISR address.
1. In the ISR, you can read the data from the USART RX buffer and process it.

#### Code

```c
#include <stdint.h>
#include <stdio.h>

// NVIC Registers
#define ISPR0 			0XE000E200U
#define ISER0			0xE000E100U
#define USART3_IRQNUM 	84 // arm cortex m7

int main(void)
{
	int bitPos = USART3_IRQNUM % 32;

	// Manually pend the pending bit for the USART3 IRQ Number, number 84, in NVIC
	uint32_t *pISPR2 = (uint32_t *)(ISPR0 + ((USART3_IRQNUM / 32)*4));
	*pISPR2 |= (1 << bitPos);

	// Enable the USART3 IRQ number in NVIC
	uint32_t *pISER2 = (uint32_t *)(ISER0 + ((USART3_IRQNUM / 32)*4));
	*pISER2 |= (1 << bitPos);


    // once it is executed, the ISPR will be cleared by the processor.
	for(;;);
}

void USART3_IRQHandler(void)
{
	printf("hello world");
}
```
