# Fault handling and analysis

## Introduction to processor fault

What is fault?

Fault is an exception generated by the processor (system exception) to indicate an error.

Why fault happened?

* Programmer handling processor by violating the design rules or may be due to interfaces with which the processor deals.
* Whenever a fault happens, internal processor registers will be updated to record the type of fault, the address of instruction at which the fult happened, and if an asspciated exception is enabled, the exception handler will be called by the processor. 
* In the exception handler programmers may implement the code to report, resolve, or recover from the fault.
* For example, if your code tries to devide a number by zero, then divide by 0 fault will be raised from the hardware, which will invoke usage fault exception handler (if enabled). In the exception handler, you may make certain decisions to get rid of the problem, like closing the task. Etc.
* Most of the time, fault happens by the programmer's mistake.

Different types of faults:

* Hard fault exception: Enabled by default, non-configurable priority. Can be disabled by code using the FAULTMASK register.
* Usage fault exception: Disabled by default, configurable priority.
* Bus fault exception: Disabled by default, configurable priority.
* Memory management fault exception: Disabled by default, configurable priority.

Causes of fault:

* Divide by zero (if enabled)
* Undefined instruction
* Attempt to execute code from memory region which is marked as execute never (XN) to prevent code injection
* MPU guarded memory region access violation by the code.
* Unaligned data access (if enabled)
* Returning to thread mode keeping active interrupt alive
* Bus error (example no response from memory device (e.g. SRAM, Flash, etc.))
* Executing SVC instruction inside SVC handler or calling a function in SVC handler which eventually executes hidden SVC instruction
* Debug monitor settings and related exceptions

## Hard fault exception

Is an exception that occurs because of an error during exception processing, or because an exception cannot be mnaged by ny other exception mechanism. It has 3rd highest fixed priority (-1) after reset and NMI meaning it has higher priority than any exception with configurable priority.

Causes:
1. Escalation of configurable fault exceptions
1. Bus error returned during a vector fetch
1. Execution of break point instruction when both halt mode and debug monitor mode are disabled.
1. Executing SVC instruction inside SVC handler. 

If configurable exception is not enabled, the exception will be escalated to hard fault exception. Otherwise, the configurable exception handler will be called.

Bus fault during vector fetch is escalated to hard fault exception.

### HardFault Status Register (HFSR)

HFSR is a 32-bit register that contains information about the hard fault exception. It is a read-only register.

Bit assignment:
1. VECTTBL: Indicates a bus fault during vector fetch.
1. FORCED: Indicates a forced hard fault generated by escalation of a configurable fault.
1. DEBUGEVT: Indicates a forced hard fault generated by escalation of a debug monitor exception.

You can read the HFSR register to determine the cause of the hard fault exception.

## Memory management fault exception

* Configurable fault exception. Disabled by default.
* You can enable this exception by configuring the processor register "System Handler Control and State Register" (SHCSR).
* When memory manage fault happens, mem manage fault exception handler will be called by the processor.
* Priority of this fault exception is configurable.

Enable the 16th bit of SHCSR register to enable memory management fault exception. 

Cuases:
1. As its name indicates this fault exception triggers when memory access violation is detected (accesss permossion by the processor or MPU).
1. Unprivileged thread mode code (such as user application or RTOS task) tries to access a memory region which is marked as "privileged access only" by the MPU.
1. Writing to memory regions which are marked as read-only by the MPU.
1. Trying to execute program code from peripheral memory region. Peripheral memory region is marked as execute never (XN) to prevent code injection. 

## Bus fault exception

* Configurable fault exception. Disabled by default.
* SHCSR register bit 17 is used to enable bus fault exception.

Causes:
* Due to error response returned by the processor bus interface during access to memory devices
    * During instruction fetch
    * During data read/write to memory devices
* If bus error happens during vector fetch, it will be escalated to hard fault exception even if bus fault exception is enabled.
* Memory device sends error response when the processor bus interface tries to access invalid or restricted memory locations which could generate a bus fault.
* When the device is not ready to accept memory transfer
* You may encounter such issues when you play with external memories such as SDRAM connected via DRAM controllers
* Unprivileged access to the private peripheral bus

## Usage fault exception

* Configurable fault exception. Disabled by default.
* SHCSR register bit 18 is used to enable usage fault exception.
* When usage fault happens, the processor executes usage fault exception handler.
* Priority of this fault exception is configurable.

Causes:
* Execution of undefined instruction (Cortex M4 supports only thumb ISA, so executing any instruction outside this ISA (like ARM ISA) will trigger usage fault exception) 
* Executing floating point instruction keeping floating point unit disabled
* Trying to switch to ARM state to execute ARM ISA instruction. The T bit of the processor decides ARM state or Thumb state. Cortex M4 supports only Thumb ISA. Hence T bit should be maintained as 1. Making T bit 0 (may happen during function call using function pointers whose 0th bit is not maintained as 1) would trigger usage fault exception.
* Trying to return to thread mode when an exception/interrupt is still active
* Unaligned memory access with multiple load or multiple store instructions.
* Attemp to devide by zero (if enabled)
* For all unaligned data access from memory (only if enabled, otherwise cortex m supports unaligned data access)

## Exercise

Write a program to enable all configurable fault exceptions, implement the fault exception handlers and cause the fault by following method:

1. Execute an undefined instruction
1. Divide by zero
1. Try executing instruction from peripheral region
1. Executing SVC inside the SVC handler
1. Executing SVC instruction inside the interrupt handler whose priority is same or lessser than SVC handler

```c
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	// 1. enable all configurable exception like usage fault, mem manage fault, and bus fault
	uint32_t *pSHCRS = (uint32_t *)0xE000ED24;
	// we are enabling bit 16, 17 and 18
	*pSHCRS |= (0x7 << 16);

	// 3. force processor to execute some undefined instruction
	uint32_t* pSRAM = (uint32_t *)0x20000000;
	// on the pSRAM we are storing invalid op-code
	*pSRAM = 0xFFFFFFFF;
	// creating function pointer and assign pSRAM to the function pointer
	void (*some_address) (void);
	// This will cause invalid state error since we are trying to execute invalid instruction in arm state
	// This caused INVSTATE in USFR register set.
	some_address = (void *)0x20000000;
	// jump to the function
//	0800031a: 7b 68         ldr     r3, [r7, #4]
//	0800031c: 98 47         blx     r3
	// r3 contains 0x20000000 at this point
	// This value will be copied to PC
	// PC tried to execute the invalid instruction
    // and usage fault exception will be raised
	some_address();

	// 4. analyze the fault

    /* Loop forever */
	for(;;);
}

// 2. implement the fault handler
void HardFault_Handler(void)
{
	printf("exception: hard fault \n");
	while(1);
}

void MemManage_Handler(void)
{
	printf("exception: mem manage fault \n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("exception: bus fault \n");
	while(1);
}

void UsageFault_Handler(void)
{
	printf("exception: usage fault \n");
	while(1);
}
```

```c
int main(void)
{
	// same as above 
	// This will cause UNDEFINSTR is set to 1 in CSFR register
	// because we are trying to read undefined instruction
	some_address = (void *)0x20000001;
	some_address();
	for(;;);
}
```

## Detecting cause of fault

* When a fault happens, the processor updates the fault status register to indicate the cause of the fault.

* HardFault Status Register (HFSR) is a 32-bit register that contains information about the hard fault exception. It is a read-only register.
* MemManage Fault Status Register (MMFSR)
* BusFault Status Register (BFSR)
* UsageFault Status Register (UFSR)

We can read the CSFR registers to determine the cause of the fault.

